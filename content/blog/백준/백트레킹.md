---
title: 15649번 N과 M (1) 문제 풀이
date: 2019-11-05 21:11:41
category: 백준
---

## 1. 문제

![Screenshot 2019-11-05 at 22.31.45](https://tva1.sinaimg.cn/large/006y8mN6gy1g8nhmmwu3jj30wa0loabq.jpg)

## 2. 개념

- 위 문제는 `백트레킹` 카테고리에 분류되어 있었습니다.
- 따라서 `백트레킹`의 개념을 이해한 후, 풀이를 진행하겠습니다.

> 백트레킹은 **모든 경우의 수**를 고려하는 알고리즘 입니다. 상태공간을 트리로 나타낼 수 있을 때 적합한 방식이며, 일종의 트리 탐색 알고리즘이라고 이해해도 됩니다.

## 3. 코드 풀이

- 코드 풀이는 주석으로 진행하겠습니다.

```python
# 1. 문제 풀이를 위한 input을 받습니다.
N, M = map(int, input().split())

# 2. 이미 사용한 숫자를 기억하는 배열을 만듭니다.
# 2.1. 초기화는 모두 False로 해야겠죠.
visited = [False] * N

# 3. 1부터 N까지의 숫자 배열을 만들어 둡니다.
numbers = range(1, N+1)

# 4. 조합된 결과를 저장할 수 있는 배열을 만듭니다.
res = [0] * M

# 5. 답을 구하기 위한 백트레킹 알고리즘을 구현합니다.
def soultion(start, end, count):
    # 5.1. 시작 값과 조합해야할 숫자가 같으면(조합을 다 만들었다면), 해당 조합을 print 후 함수를 빠져나옵니다.
    if(start == count):
        print(*res)
        return

    # 5.2. index 0부터 end-1까지 순회하며 조합을 찾아냅니다.
    for i in range(end):
        # 5.3. 이미 조합에 사용한 index는 건너 뜁니다.
        if(visited[i] == False):
            # 5.4. 현재 방문한 index를 True로 바꿉니다.
            visited[i] = True
            # 5.5. 해당 조합에 현재 index에 해당하는 숫자를 할당합니다.
            res[start] = numbers[i]
            # 5.6. 재귀함수의 특성을 활용해 start+1 을 더해 위의 escape case에 도달할 때까지 반복적으로 순회합니다.
            soultion(start+1, end, count)
            # 5.7. 위의 재귀함수를 빠져나온 후, 해당 index를 초기화 합니다.
            visited[i] = False

soultion(0, N, M)
```
