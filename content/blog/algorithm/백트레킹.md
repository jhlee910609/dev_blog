---
title: 백트레킹
date: 2020-01-04 18:01:14
category: algorithm
---

## 백트레킹 알고리즘

- 모든 경우의 수를 고려해야하는 경우, ‘백트레킹’ 알고리즘을 고려해볼 수 있습니다.
- ‘백트레킹’에 대한 간략한 설명은 아래와 같습니다.

> 모든 경우의 수를 전부 고려하는 알고리즘. 상태공간을 트리로 나타낼 수 있을 때 적합한 방식이다. 일종의 트리 탐색 알고리즘이라고 봐도 된다. 방식에 따라서 깊이우선탐색(Depth First Search, DFS)과 너비우선탐색(Breadth First Search, BFS), 최선 우선 탐색(Best First Search/Heuristic Search)이 있다. [참고: 나무위키]

- 백트레킹 기법을 사용하는 이유는 크게 두 가지입니다.
  - 이미 지나간 원소(저장된 요소)에 대한 **'배제'**
  - 그로 인한 **'풀이 시간 단축'**
- 이 부분을 고려해서 다음 문제를 풀어 보았습니다.

## 15649번 문제

![스크린샷 2020-01-04 오후 8.04.27](https://tva1.sinaimg.cn/large/006tNbRwgy1gakqlknazmj312u0u042m.jpg)

## 풀이

- 문제의 핵심은 주어진 `M`만큼의 수열을 만드는 것 입니다.
- 자세한 풀이는 아래 코드와 함께 주석으로 진행하겠습니다.

```python
N, M = list(map(int, input().split()))

# 답 저장하는 배열 (아래 완성된 temp수열을 담는 배열)
result = []

# 이미 선택된 숫자를 기록하는 공간 (N개의 T/F)
visited = [False for _ in range(N)]

# 수열을 완성해가는 배열
temp = [0 for _ in range(M)]

# 기본 숫자 모음 
arr = [i+1 for i in range(0, N)]

def solution(n, m, k):
    global result, temp, visited, arr
    if(m == k):
      	# 완성된 temp 배열 복제하여 저장
        result.append(temp[:])
        return

    for i in range(n):
        if(visited[i] == False):
          	# 사용할 숫자이므로 True로 기록
            visited[i] = True
            
            # 수열의 k번째에 저장
            temp[k] = arr[i]
            
            # 재귀로 돔
            solution(n, m, k+1)
            
            # 빠져나옴 => 사용 끝난 숫자 False로 기록
            visited[i] = False
solution(N, M, 0)
```



## 15650번 풀이

- 위의 문제의 응용 버전입니다.
- 의외로 쉽습니다.

![스크린샷 2020-01-04 오후 8.21.10](https://tva1.sinaimg.cn/large/006tNbRwgy1gakr344fx5j312x0u0wiq.jpg)

## 풀이

- 거꾸로 했을 때, 앞의 숫자를 안타게 하면 되게 하면 됩니다.
- 조금만 응용해보려고 노력하면 충분히 풀 수 있는 문제입니다.
- `cur parameter`만 잘 봐주시면 됩니다.

```python
N, M = list(map(int, input().split()))

# 답 저장하는 배열 (아래 완성된 temp수열을 담는 배열)
result = []

# 이미 선택된 숫자를 기록하는 공간 (N개의 T/F)
visited = [False for _ in range(N)]

# 수열을 완성해가는 배열
temp = [0 for _ in range(M)]

# 기본 숫자 모음 
arr = [i+1 for i in range(0, N)]

def solution(n, m, k, cur):
    global result, temp, visited, arr
    if(m == k):
      	# 완성된 temp 배열 복제하여 저장
        result.append(temp[:])
        return

    for i in range(cur, n):
        if(visited[i] == False):
          	# 사용할 숫자이므로 True로 기록
            visited[i] = True
            
            # 수열의 k번째에 저장
            temp[k] = arr[i]
            
            # 재귀로 돔
            solution(n, m, k+1, cur+1)
            
            # 빠져나옴 => 사용 끝난 숫자 False로 기록
            visited[i] = False
solution(N, M, 0, 0)
```

